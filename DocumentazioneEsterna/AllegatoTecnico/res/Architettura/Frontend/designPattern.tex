\subsubsection{Design pattern utilizzati}
All'interno del modulo \textbf{Front-end\ped{G}}, come detto precedentemente, vengono utilizzati due design pattern:
\begin{itemize}
	\item \textbf{Presentational and container components pattern}:\\ 
	Consiste nel dividere i component di una singola pagina in due tipi: \textit{presentational} e \textit{container}.\\
	 I primi sono coloro che non presentano alcuno stato o funzione al loro interno, e si occupano solamente di mostrare dati e/o richiamare funzioni provenienti da component superiori. Ogni \textit{presentational} component può avere come figli solamente altri component dello stesso tipo. \\
	 I \textit{container} components invece possono avere al loro interno variabili di stato e/o funzioni per la gestione di queste ultime. Inoltre, non hanno restrizioni su che tipo devono avere i figli.\\
	 Tramite questo pattern è possibile, quindi, comporre una pagina attraverso un insieme di components, ognuno con le sue responsabilità ben definite. Ci permette inoltre di dividere in modo chiaro la vista e la logica del programma.\\
	 L'esempio della dashboard\ped{G} (\S{2.2.3}) mostra come esso possa essere implementato correttamente.
	\item \textbf{Observer pattern}: \\L'observer pattern non viene implementato manualmente, ma è nativo nei React\ped{G} components. Nell'esempio dell'inserimento di un prodotto (\S{2.2.4}), una volta che lo stato in \textit{ListingSection} cambia, viene provocato un re-rendering del component e di tutti i suoi component figli (senza costruirli nuovamente).\\ Quindi, in generale, lo stato del component è il nostro \textit{observable}; infatti il component osserva quando lo stato viene aggiornato, renderizza se stesso prendendo i nuovi valori e notifica i component figli di renderizzarsi, aggiornando automaticamente i props passati.
\end{itemize} 